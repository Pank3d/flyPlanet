name: Deploy VLESS Reality Stack

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
  VPS_PORT: ${{ secrets.VPS_PORT || 22 }}
  REALITY_DEST: ${{ secrets.REALITY_DEST || 'yandex.ru' }}
  REALITY_SNI: ${{ secrets.REALITY_SNI || 'yandex.ru ya.ru' }}
  BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}

jobs:
  deploy-xray:
    name: Deploy Xray Server
    runs-on: ubuntu-latest
    outputs:
      public_key: ${{ steps.set_outputs.outputs.public_key }}
      server_ip: ${{ steps.set_outputs.outputs.server_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install paramiko

      - name: Deploy Xray to VPS
        id: deploy_xray
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          script: |
            set -e

            echo "=== Installing Xray-core ==="

            # Установка Xray если еще не установлен
            if ! command -v xray &> /dev/null; then
              bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
            else
              echo "Xray already installed"
            fi

            # Генерация ключей REALITY
            echo "=== Generating REALITY keys ==="
            KEYS=$(xray x25519)
            echo "Raw keys output: $KEYS"

            # Новый формат вывода xray x25519: PrivateKey / Password (PublicKey)
            PRIVATE_KEY=$(echo "$KEYS" | grep "PrivateKey:" | awk '{print $2}')
            PUBLIC_KEY=$(echo "$KEYS" | grep "Password:" | awk '{print $2}')

            # Если не нашли в новом формате, пробуем старый формат
            if [ -z "$PRIVATE_KEY" ]; then
              PRIVATE_KEY=$(echo "$KEYS" | grep "Private key:" | awk '{print $3}')
            fi
            if [ -z "$PUBLIC_KEY" ]; then
              PUBLIC_KEY=$(echo "$KEYS" | grep "Public key:" | awk '{print $3}')
            fi

            # Проверка что ключи сгенерированы
            if [ -z "$PRIVATE_KEY" ] || [ -z "$PUBLIC_KEY" ]; then
              echo "ERROR: Failed to generate keys!"
              echo "Keys output: $KEYS"
              exit 1
            fi

            echo "Private Key: $PRIVATE_KEY"
            echo "Public Key: $PUBLIC_KEY"

            # Генерация UUID
            UUID=$(xray uuid)
            echo "UUID: $UUID"

            # Генерация Short ID
            SHORT_ID=$(openssl rand -hex 4)
            echo "Short ID: $SHORT_ID"

            # Создание конфига Xray с прямой подстановкой переменных
            echo "=== Creating Xray config ==="
            cat > /usr/local/etc/xray/config.json << EOF
            {
              "log": {
                "loglevel": "warning"
              },
              "inbounds": [
                {
                  "port": 443,
                  "protocol": "vless",
                  "settings": {
                    "clients": [
                      {
                        "id": "$UUID",
                        "flow": "xtls-rprx-vision"
                      }
                    ],
                    "decryption": "none"
                  },
                  "streamSettings": {
                    "network": "tcp",
                    "security": "reality",
                    "realitySettings": {
                      "show": false,
                      "dest": "${{ env.REALITY_DEST }}:443",
                      "xver": 0,
                      "serverNames": [
                        "${{ env.REALITY_DEST }}"
                      ],
                      "privateKey": "$PRIVATE_KEY",
                      "shortIds": [
                        "$SHORT_ID"
                      ]
                    }
                  }
                }
              ],
              "outbounds": [
                {
                  "protocol": "freedom",
                  "tag": "direct"
                }
              ]
            }
            EOF

            # Проверка что конфиг создан правильно
            echo "=== Verifying config ==="
            if grep -q "PLACEHOLDER" /usr/local/etc/xray/config.json; then
              echo "ERROR: Config still contains PLACEHOLDER!"
              cat /usr/local/etc/xray/config.json
              exit 1
            fi
            echo "Config created successfully, no placeholders found"

            # Сохранение информации для бота
            mkdir -p ~/xray-info
            cat > ~/xray-info/reality_server_info.json << EOF
            {
              "public_key": "$PUBLIC_KEY",
              "server": "${{ env.VPS_HOST }}",
              "uuid": "$UUID",
              "short_id": "$SHORT_ID",
              "dest": "${{ env.REALITY_DEST }}",
              "sni": "${{ env.REALITY_DEST }}"
            }
            EOF

            echo "Info saved to ~/xray-info/reality_server_info.json"

            # Запуск Xray
            echo "=== Starting Xray ==="
            systemctl enable xray
            systemctl restart xray

            # Проверка статуса
            sleep 2
            systemctl status xray --no-pager || true

            echo ""
            echo "=== Xray Installation Complete ==="
            echo "Public Key: $PUBLIC_KEY"
            echo "Server: ${{ env.VPS_HOST }}"
            echo "Port: 443"

      - name: Read PUBLIC_KEY from VPS
        id: read_key
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          script: |
            echo "=== Reading PUBLIC_KEY from VPS ==="
            if [ -f ~/xray-info/reality_server_info.json ]; then
              echo "File exists, extracting PUBLIC_KEY..."
              cat ~/xray-info/reality_server_info.json
              echo ""
              echo "Extracted PUBLIC_KEY:"
              cat ~/xray-info/reality_server_info.json | grep -o '"public_key":"[^"]*"' | cut -d'"' -f4
            else
              echo "ERROR: File ~/xray-info/reality_server_info.json not found!"
              echo ""
            fi

      - name: Extract and save PUBLIC_KEY
        id: set_outputs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== Extracting PUBLIC_KEY from previous step ==="
          echo "Raw output from read_key step:"
          echo "${{ steps.read_key.outputs.stdout }}"
          echo ""

          # Извлекаем последнюю непустую строку (это должен быть PUBLIC_KEY)
          PUBLIC_KEY=$(echo "${{ steps.read_key.outputs.stdout }}" | grep -v "^$" | grep -v "===" | grep -v "File exists" | grep -v "Extracted PUBLIC_KEY" | tail -n 1 | tr -d '\r\n\t ')

          echo "Extracted value: '$PUBLIC_KEY'"
          echo "Length: ${#PUBLIC_KEY}"

          # Если не получилось с VPS, пробуем из секретов
          if [ -z "$PUBLIC_KEY" ] || [ "$PUBLIC_KEY" = "" ]; then
            echo "PUBLIC_KEY is empty, trying GitHub secrets..."
            PUBLIC_KEY="${{ secrets.XRAY_PUBLIC_KEY }}"
            if [ -n "$PUBLIC_KEY" ]; then
              echo "Using PUBLIC_KEY from GitHub secrets: ${PUBLIC_KEY:0:20}..."
            fi
          else
            echo "PUBLIC_KEY extracted from VPS: ${PUBLIC_KEY:0:20}..."

            # Автоматически сохраняем в GitHub Secrets для следующих запусков
            echo "Saving PUBLIC_KEY to GitHub Secrets..."

            # Используем GitHub CLI для обновления секрета
            echo "$PUBLIC_KEY" | gh secret set XRAY_PUBLIC_KEY --repo ${{ github.repository }} || echo "Failed to save secret (this is ok)"
          fi

          SERVER_IP="${{ env.VPS_HOST }}"

          # Если PUBLIC_KEY все еще пустой
          if [ -z "$PUBLIC_KEY" ]; then
            echo "WARNING: Could not get PUBLIC_KEY, using placeholder"
            echo "Check 'Deploy Xray to VPS' logs for the actual PUBLIC_KEY"
            PUBLIC_KEY="PLACEHOLDER_KEY"
          fi

          echo "public_key=$PUBLIC_KEY" >> $GITHUB_OUTPUT
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo ""
          echo "=== Final values ==="
          echo "PUBLIC_KEY: ${PUBLIC_KEY:0:20}..."
          echo "SERVER_IP: $SERVER_IP"

  deploy-bot:
    name: Deploy Telegram Bot
    runs-on: ubuntu-latest
    needs: deploy-xray

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Get credentials from previous job
        id: extract
        run: |
          PUBLIC_KEY="${{ needs.deploy-xray.outputs.public_key }}"
          SERVER_IP="${{ needs.deploy-xray.outputs.server_ip }}"

          # Если не получили из artifact, используем secrets
          if [ -z "$PUBLIC_KEY" ]; then
            PUBLIC_KEY="${{ secrets.XRAY_PUBLIC_KEY }}"
            echo "Using PUBLIC_KEY from secrets"
          fi

          if [ -z "$SERVER_IP" ]; then
            SERVER_IP="${{ env.VPS_HOST }}"
          fi

          # Если PUBLIC_KEY все еще пустой, используем placeholder
          if [ -z "$PUBLIC_KEY" ]; then
            PUBLIC_KEY="PLACEHOLDER_KEY_CHANGE_ME"
            echo "Warning: PUBLIC_KEY is empty, using placeholder"
          fi

          echo "public_key=$PUBLIC_KEY" >> $GITHUB_OUTPUT
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "Server IP: $SERVER_IP"
          echo "Public Key (first 20 chars): ${PUBLIC_KEY:0:20}..."

      - name: Prepare deployment directory
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          script: |
            set -e

            # Install Docker if not installed
            if ! command -v docker &> /dev/null; then
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              systemctl enable docker
              systemctl start docker
            fi

            # Install Docker Compose if not installed
            if ! docker compose version &> /dev/null; then
              if ! command -v docker-compose &> /dev/null; then
                curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                chmod +x /usr/local/bin/docker-compose
              fi
            fi

            # Create project directory
            mkdir -p ~/vless-reality-project
            cd ~/vless-reality-project

      - name: Copy docker-compose file
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          source: "docker-compose.yml"
          target: "~/vless-reality-project/"

      - name: Copy bot files
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          source: "bot/*"
          target: "~/vless-reality-project/"
          strip_components: 0

      - name: Deploy with Docker
        uses: appleboy/ssh-action@v1.0.0
        env:
          BOT_TOKEN: ${{ env.BOT_TOKEN }}
          SERVER_IP: ${{ steps.extract.outputs.server_ip }}
          PUBLIC_KEY: ${{ steps.extract.outputs.public_key }}
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          envs: BOT_TOKEN,SERVER_IP,PUBLIC_KEY
          script: |
            cd ~/vless-reality-project

            # Определяем команду docker-compose (новая или старая версия)
            if docker compose version &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            else
              DOCKER_COMPOSE="docker-compose"
            fi
            echo "Using: $DOCKER_COMPOSE"

            # Debug: show what files we have
            echo "=== Files in directory ==="
            ls -la
            echo ""
            echo "=== Bot directory ==="
            ls -la bot/ || echo "No bot directory"

            # Create .env file directly (переменные уже экспортированы через envs)
            echo "BOT_TOKEN=${BOT_TOKEN}" > .env
            echo "SERVER_IP=${SERVER_IP}" >> .env
            echo "PUBLIC_KEY=${PUBLIC_KEY}" >> .env

            # Debug: show .env content (without sensitive data)
            echo ""
            echo "=== .env created ==="
            cat .env | sed 's/=.*/=***/'

            # Stop old container
            echo ""
            echo "=== Stopping old containers ==="
            $DOCKER_COMPOSE down 2>/dev/null || true

            # Remove old images
            docker rmi vless-reality-project-bot 2>/dev/null || true

            # Start with Docker Compose
            echo ""
            echo "=== Building and starting Docker Compose ==="
            $DOCKER_COMPOSE up -d --build

            # Wait a bit for container to start
            sleep 5

            # Show status
            echo ""
            echo "=== Docker Compose Status ==="
            $DOCKER_COMPOSE ps

            echo ""
            echo "=== Container Logs ==="
            $DOCKER_COMPOSE logs bot

            echo ""
            echo "=== Deployment Complete ==="

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [deploy-xray, deploy-bot]
    if: always()

    steps:
      - name: Send Telegram notification
        uses: appleboy/telegram-action@master
        continue-on-error: true
        with:
          to: ${{ secrets.NOTIFICATION_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          message: |
            Deployment completed

            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}

            Xray: ${{ needs.deploy-xray.result }}
            Bot: ${{ needs.deploy-bot.result }}

            Server: ${{ secrets.VPS_HOST }}
