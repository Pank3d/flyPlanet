name: Deploy VLESS Reality Stack

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
  VPS_PORT: ${{ secrets.VPS_PORT || 22 }}
  REALITY_DEST: ${{ secrets.REALITY_DEST || 'yandex.ru' }}
  REALITY_SNI: ${{ secrets.REALITY_SNI || 'yandex.ru ya.ru' }}
  BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}

jobs:
  deploy-xray:
    name: Deploy Xray Server
    runs-on: ubuntu-latest
    outputs:
      public_key: ${{ steps.set_outputs.outputs.public_key }}
      server_ip: ${{ steps.set_outputs.outputs.server_ip }}
      short_id: ${{ steps.set_outputs.outputs.short_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install paramiko

      - name: Deploy Xray to VPS
        id: deploy_xray
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          script: |
            set -e

            echo "=== Installing Xray-core ==="

            # Установка Xray если еще не установлен
            if ! command -v xray &> /dev/null; then
              bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
            else
              echo "Xray already installed"
            fi

            # Генерация ключей REALITY
            echo "=== Generating REALITY keys ==="
            KEYS=$(xray x25519)
            echo "Raw keys output: $KEYS"

            # Новый формат вывода xray x25519: PrivateKey / Password (PublicKey)
            PRIVATE_KEY=$(echo "$KEYS" | grep "PrivateKey:" | awk '{print $2}')
            PUBLIC_KEY=$(echo "$KEYS" | grep "Password:" | awk '{print $2}')

            # Если не нашли в новом формате, пробуем старый формат
            if [ -z "$PRIVATE_KEY" ]; then
              PRIVATE_KEY=$(echo "$KEYS" | grep "Private key:" | awk '{print $3}')
            fi
            if [ -z "$PUBLIC_KEY" ]; then
              PUBLIC_KEY=$(echo "$KEYS" | grep "Public key:" | awk '{print $3}')
            fi

            # Проверка что ключи сгенерированы
            if [ -z "$PRIVATE_KEY" ] || [ -z "$PUBLIC_KEY" ]; then
              echo "ERROR: Failed to generate keys!"
              echo "Keys output: $KEYS"
              exit 1
            fi

            echo "Private Key: $PRIVATE_KEY"
            echo "Public Key: $PUBLIC_KEY"

            # Генерация UUID
            UUID=$(xray uuid)
            echo "UUID: $UUID"

            # Генерация Short ID
            SHORT_ID=$(openssl rand -hex 4)
            echo "Short ID: $SHORT_ID"

            # Создаем директорию для логов
            mkdir -p /var/log/xray
            chmod 755 /var/log/xray

            # Сохранение информации для бота
            mkdir -p ~/xray-info
            cat > ~/xray-info/reality_server_info.json << EOF
            {
              "public_key": "$PUBLIC_KEY",
              "server": "${{ env.VPS_HOST }}",
              "uuid": "$UUID",
              "short_id": "$SHORT_ID",
              "dest": "${{ env.REALITY_DEST }}",
              "sni": "${{ env.REALITY_DEST }}"
            }
            EOF

            echo "Info saved to ~/xray-info/reality_server_info.json"

            # Настройка firewall для множественных портов
            echo ""
            echo "=== Configuring Firewall for Multiple Ports ==="

            # Порты для открытия (5 профилей)
            PORTS="443 8443 2053 2083 2087"

            # Проверяем UFW
            if command -v ufw &> /dev/null; then
              echo "Configuring UFW..."
              for port in $PORTS; do
                ufw allow $port/tcp
                echo "  - Port $port/tcp allowed"
              done
              echo 'y' | ufw enable
              echo "UFW configured"
            else
              echo "UFW not found, using iptables..."
              # Устанавливаем iptables если не установлен
              if ! command -v iptables &> /dev/null; then
                apt-get install -y iptables iptables-persistent
              fi

              # Открываем порты через iptables
              for port in $PORTS; do
                iptables -A INPUT -p tcp --dport $port -j ACCEPT
                echo "  - Port $port/tcp allowed"
              done

              mkdir -p /etc/iptables
              iptables-save > /etc/iptables/rules.v4
              echo "iptables configured"
            fi

            # Настройка DPI bypass через iptables
            echo ""
            echo "=== Configuring DPI Bypass ==="

            # Очищаем старые правила
            iptables -t mangle -F POSTROUTING 2>/dev/null || true

            # 1. Фрагментация TCP пакетов (MSS = 1200)
            iptables -t mangle -A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1200

            # 2. Модификация TTL
            iptables -t mangle -A POSTROUTING -j TTL --ttl-set 65

            # Сохраняем правила
            if command -v netfilter-persistent &> /dev/null; then
              netfilter-persistent save
            else
              mkdir -p /etc/iptables
              iptables-save > /etc/iptables/rules.v4
            fi

            echo "DPI bypass configured:"
            echo "  - TCP MSS: 1200 (packet fragmentation)"
            echo "  - TTL: 65"

            # Установка и настройка Cloudflare WARP
            echo ""
            echo "=== Installing Cloudflare WARP ==="

            # Проверяем установлен ли WARP
            if ! command -v warp-cli &> /dev/null; then
              echo "Installing WARP client..."

              # Добавляем репозиторий Cloudflare
              curl -fsSL https://pkg.cloudflareclient.com/pubkey.gpg | gpg --yes --dearmor --output /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg

              echo "deb [arch=amd64 signed-by=/usr/share/keyrings/cloudflare-warp-archive-keyring.gpg] https://pkg.cloudflareclient.com/ jammy main" > /etc/apt/sources.list.d/cloudflare-client.list

              apt-get update
              apt-get install -y cloudflare-warp
            else
              echo "WARP already installed"
            fi

            # Запускаем WARP daemon
            echo "Starting WARP daemon..."
            systemctl enable warp-svc
            systemctl restart warp-svc

            # Ждем запуска daemon
            sleep 5

            # Регистрируем и запускаем WARP
            echo "Registering WARP..."
            warp-cli registration delete 2>/dev/null || true
            warp-cli registration new 2>/dev/null || true

            # Устанавливаем режим proxy
            echo "Setting WARP to proxy mode..."
            warp-cli mode proxy 2>/dev/null || true

            # Подключаем WARP
            echo "Connecting WARP..."
            warp-cli connect 2>/dev/null || true

            # Ждем подключения
            sleep 5

            # Проверяем статус
            echo "WARP Status:"
            warp-cli status 2>/dev/null || echo "WARP not connected (will use direct routing)"

            # Проверяем порт
            echo ""
            echo "Checking WARP SOCKS5 proxy port:"
            ss -tulpn | grep 40000 || echo "Port 40000 not listening (WARP proxy not active)"

            # Обновляем Xray конфиг с мультипортовой конфигурацией
            echo ""
            echo "=== Creating multi-port Xray config for different operators ==="
            cat > /usr/local/etc/xray/config.json << XRAYEOF
            {
              "log": {
                "loglevel": "debug",
                "access": "/var/log/xray/access.log",
                "error": "/var/log/xray/error.log"
              },
              "inbounds": [
                {
                  "port": 443,
                  "protocol": "vless",
                  "tag": "inbound-443",
                  "settings": {
                    "clients": [{"id": "$UUID", "flow": "xtls-rprx-vision"}],
                    "decryption": "none"
                  },
                  "streamSettings": {
                    "network": "tcp",
                    "security": "reality",
                    "realitySettings": {
                      "show": false,
                      "dest": "yandex.ru:443",
                      "xver": 0,
                      "serverNames": ["yandex.ru", "ya.ru", "passport.yandex.ru", "disk.yandex.ru"],
                      "privateKey": "$PRIVATE_KEY",
                      "shortIds": ["", "a1b2c3d4"]
                    }
                  }
                },
                {
                  "port": 8443,
                  "protocol": "vless",
                  "tag": "inbound-8443",
                  "settings": {
                    "clients": [{"id": "$UUID", "flow": "xtls-rprx-vision"}],
                    "decryption": "none"
                  },
                  "streamSettings": {
                    "network": "tcp",
                    "security": "reality",
                    "realitySettings": {
                      "show": false,
                      "dest": "vk.com:443",
                      "xver": 0,
                      "serverNames": ["vk.com", "vk.ru", "userapi.com", "vk.me"],
                      "privateKey": "$PRIVATE_KEY",
                      "shortIds": ["", "e5f6g7h8"]
                    }
                  }
                },
                {
                  "port": 2053,
                  "protocol": "vless",
                  "tag": "inbound-2053",
                  "settings": {
                    "clients": [{"id": "$UUID", "flow": "xtls-rprx-vision"}],
                    "decryption": "none"
                  },
                  "streamSettings": {
                    "network": "tcp",
                    "security": "reality",
                    "realitySettings": {
                      "show": false,
                      "dest": "mail.ru:443",
                      "xver": 0,
                      "serverNames": ["mail.ru", "e.mail.ru", "cloud.mail.ru", "my.mail.ru"],
                      "privateKey": "$PRIVATE_KEY",
                      "shortIds": ["", "i9j0k1l2"]
                    }
                  }
                },
                {
                  "port": 2083,
                  "protocol": "vless",
                  "tag": "inbound-2083",
                  "settings": {
                    "clients": [{"id": "$UUID", "flow": "xtls-rprx-vision"}],
                    "decryption": "none"
                  },
                  "streamSettings": {
                    "network": "tcp",
                    "security": "reality",
                    "realitySettings": {
                      "show": false,
                      "dest": "ok.ru:443",
                      "xver": 0,
                      "serverNames": ["ok.ru", "www.ok.ru", "m.ok.ru"],
                      "privateKey": "$PRIVATE_KEY",
                      "shortIds": ["", "m3n4o5p6"]
                    }
                  }
                },
                {
                  "port": 2087,
                  "protocol": "vless",
                  "tag": "inbound-2087",
                  "settings": {
                    "clients": [{"id": "$UUID", "flow": "xtls-rprx-vision"}],
                    "decryption": "none"
                  },
                  "streamSettings": {
                    "network": "tcp",
                    "security": "reality",
                    "realitySettings": {
                      "show": false,
                      "dest": "rutube.ru:443",
                      "xver": 0,
                      "serverNames": ["rutube.ru", "www.rutube.ru"],
                      "privateKey": "$PRIVATE_KEY",
                      "shortIds": ["", "q7r8s9t0"]
                    }
                  }
                },
                {
                  "port": 2096,
                  "protocol": "vless",
                  "tag": "inbound-2096",
                  "settings": {
                    "clients": [{"id": "$UUID", "flow": "xtls-rprx-vision"}],
                    "decryption": "none"
                  },
                  "streamSettings": {
                    "network": "tcp",
                    "security": "reality",
                    "realitySettings": {
                      "show": false,
                      "dest": "sberbank.ru:443",
                      "xver": 0,
                      "serverNames": ["sberbank.ru", "www.sberbank.ru", "online.sberbank.ru"],
                      "privateKey": "$PRIVATE_KEY",
                      "shortIds": ["", "u1v2w3x4"]
                    }
                  }
                }
              ],
              "outbounds": [
                {
                  "protocol": "freedom",
                  "tag": "direct"
                },
                {
                  "protocol": "socks",
                  "tag": "warp",
                  "settings": {
                    "servers": [
                      {
                        "address": "127.0.0.1",
                        "port": 40000
                      }
                    ]
                  }
                },
                {
                  "protocol": "blackhole",
                  "tag": "block"
                }
              ],
              "routing": {
                "domainStrategy": "IPIfNonMatch",
                "rules": [
                  {
                    "type": "field",
                    "network": "tcp,udp",
                    "outboundTag": "direct"
                  }
                ]
              }
            }
            XRAYEOF

            echo "Xray multi-port config created with 6 profiles for different operators"

            # Запуск Xray
            echo ""
            echo "=== Starting Xray ==="
            systemctl enable xray
            systemctl restart xray

            # Проверка статуса
            sleep 2
            systemctl status xray --no-pager || true

            echo ""
            echo "=== Installation Complete ==="
            echo "Public Key: $PUBLIC_KEY"
            echo "Server: ${{ env.VPS_HOST }}"
            echo ""
            echo "Configured ports for different operators:"
            echo "  ✓ Port 443:  Yandex (Tele2, Beeline)"
            echo "  ✓ Port 8443: VK (MTS, Beeline)"
            echo "  ✓ Port 2053: Mail.ru (Beeline, Tele2)"
            echo "  ✓ Port 2083: OK.ru (Megafon, MTS)"
            echo "  ✓ Port 2087: RuTube (Universal)"
            echo "  ✓ Port 2096: Sberbank (Universal)"
            echo ""
            echo "Anti-censorship features enabled:"
            echo "  ✓ DPI bypass (TCP MSS fragmentation, TTL modification)"
            echo "  ✓ WARP routing for blocked IPs/domains"
            echo "  ✓ Multi-port configuration with Russian SNI"
            echo "  ✓ Debug logging"

      - name: Read server info from VPS
        id: read_key
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          script: |
            echo "=== Reading server info from VPS ==="
            if [ -f ~/xray-info/reality_server_info.json ]; then
              echo "File exists, extracting data..."
              cat ~/xray-info/reality_server_info.json
              echo ""
              echo "Extracted PUBLIC_KEY:"
              cat ~/xray-info/reality_server_info.json | grep -o '"public_key":"[^"]*"' | cut -d'"' -f4
              echo ""
              echo "Extracted SHORT_ID:"
              cat ~/xray-info/reality_server_info.json | grep -o '"short_id":"[^"]*"' | cut -d'"' -f4
            else
              echo "ERROR: File ~/xray-info/reality_server_info.json not found!"
              echo ""
            fi

      - name: Extract and save server info
        id: set_outputs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== Extracting server info from previous step ==="
          echo "Raw output from read_key step:"
          echo "${{ steps.read_key.outputs.stdout }}"
          echo ""

          # Извлекаем PUBLIC_KEY
          PUBLIC_KEY=$(echo "${{ steps.read_key.outputs.stdout }}" | grep -A1 "Extracted PUBLIC_KEY:" | tail -n 1 | tr -d '\r\n\t ')

          # Извлекаем SHORT_ID
          SHORT_ID=$(echo "${{ steps.read_key.outputs.stdout }}" | grep -A1 "Extracted SHORT_ID:" | tail -n 1 | tr -d '\r\n\t ')

          echo "Extracted PUBLIC_KEY: '$PUBLIC_KEY'"
          echo "Extracted SHORT_ID: '$SHORT_ID'"

          # Если не получилось с VPS, пробуем из секретов
          if [ -z "$PUBLIC_KEY" ] || [ "$PUBLIC_KEY" = "" ]; then
            echo "PUBLIC_KEY is empty, trying GitHub secrets..."
            PUBLIC_KEY="${{ secrets.XRAY_PUBLIC_KEY }}"
            if [ -n "$PUBLIC_KEY" ]; then
              echo "Using PUBLIC_KEY from GitHub secrets: ${PUBLIC_KEY:0:20}..."
            fi
          else
            echo "PUBLIC_KEY extracted from VPS: ${PUBLIC_KEY:0:20}..."

            # Автоматически сохраняем в GitHub Secrets для следующих запусков
            echo "Saving PUBLIC_KEY to GitHub Secrets..."
            echo "$PUBLIC_KEY" | gh secret set XRAY_PUBLIC_KEY --repo ${{ github.repository }} || echo "Failed to save secret (this is ok)"
          fi

          # Если SHORT_ID не получен, используем fallback
          if [ -z "$SHORT_ID" ] || [ "$SHORT_ID" = "" ]; then
            echo "SHORT_ID is empty, using fallback value be0a50b4"
            SHORT_ID="be0a50b4"
          else
            echo "SHORT_ID extracted from VPS: $SHORT_ID"
          fi

          SERVER_IP="${{ env.VPS_HOST }}"

          # Если PUBLIC_KEY все еще пустой
          if [ -z "$PUBLIC_KEY" ]; then
            echo "WARNING: Could not get PUBLIC_KEY, using placeholder"
            echo "Check 'Deploy Xray to VPS' logs for the actual PUBLIC_KEY"
            PUBLIC_KEY="PLACEHOLDER_KEY"
          fi

          echo "public_key=$PUBLIC_KEY" >> $GITHUB_OUTPUT
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "short_id=$SHORT_ID" >> $GITHUB_OUTPUT
          echo ""
          echo "=== Final values ==="
          echo "PUBLIC_KEY: ${PUBLIC_KEY:0:20}..."
          echo "SERVER_IP: $SERVER_IP"
          echo "SHORT_ID: $SHORT_ID"

  deploy-bot:
    name: Deploy Telegram Bot
    runs-on: ubuntu-latest
    needs: deploy-xray

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Prepare deployment directory
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          script: |
            set -e

            # Install Docker if not installed
            if ! command -v docker &> /dev/null; then
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              systemctl enable docker
              systemctl start docker
            fi

            # Install Docker Compose if not installed
            if ! docker compose version &> /dev/null; then
              if ! command -v docker-compose &> /dev/null; then
                curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                chmod +x /usr/local/bin/docker-compose
              fi
            fi

            # Create project directory
            mkdir -p ~/vless-reality-project
            cd ~/vless-reality-project

      - name: Copy docker-compose file
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          source: "docker-compose.yml"
          target: "~/vless-reality-project/"

      - name: Copy bot files
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          source: "bot/*"
          target: "~/vless-reality-project/"
          strip_components: 0

      - name: Copy create-env script
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          source: "create-env.sh"
          target: "~/vless-reality-project/"

      - name: Deploy with Docker
        uses: appleboy/ssh-action@v1.0.0
        env:
          BOT_TOKEN: ${{ env.BOT_TOKEN }}
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASSWORD }}
          port: ${{ env.VPS_PORT }}
          envs: BOT_TOKEN
          script: |
            cd ~/vless-reality-project

            # Определяем команду docker-compose (новая или старая версия)
            if docker compose version &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            else
              DOCKER_COMPOSE="docker-compose"
            fi
            echo "Using: $DOCKER_COMPOSE"

            # Debug: show what files we have
            echo "=== Files in directory ==="
            ls -la
            echo ""
            echo "=== Bot directory ==="
            ls -la bot/ || echo "No bot directory"

            # Запускаем create-env.sh скрипт для создания .env
            echo ""
            echo "=== Creating .env from server info ==="
            chmod +x create-env.sh
            ./create-env.sh "${BOT_TOKEN}"

            # Stop old container
            echo ""
            echo "=== Stopping old containers ==="
            $DOCKER_COMPOSE down 2>/dev/null || true

            # Remove old images
            docker rmi vless-reality-project-bot 2>/dev/null || true

            # Start with Docker Compose
            echo ""
            echo "=== Building and starting Docker Compose ==="
            $DOCKER_COMPOSE up -d --build

            # Wait a bit for container to start
            sleep 5

            # Show status
            echo ""
            echo "=== Docker Compose Status ==="
            $DOCKER_COMPOSE ps

            echo ""
            echo "=== Container Logs ==="
            $DOCKER_COMPOSE logs bot

            echo ""
            echo "=== Deployment Complete ==="

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [deploy-xray, deploy-bot]
    if: always()

    steps:
      - name: Send Telegram notification
        uses: appleboy/telegram-action@master
        continue-on-error: true
        with:
          to: ${{ secrets.NOTIFICATION_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          message: |
            Deployment completed

            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}

            Xray: ${{ needs.deploy-xray.result }}
            Bot: ${{ needs.deploy-bot.result }}

            Server: ${{ secrets.VPS_HOST }}
